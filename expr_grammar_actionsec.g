tokens SYM_EOF SYM_IDENTIFIER<string> SYM_INTEGER<int> SYM_PLUS SYM_MINUS SYM_ASTERISK SYM_DIV SYM_MOD
tokens SYM_LPARENTHESIS SYM_RPARENTHESIS SYM_LBRACE SYM_RBRACE
tokens SYM_ASSIGN SYM_SEMICOLON SYM_RETURN SYM_IF SYM_WHILE SYM_ELSE SYM_COMMA SYM_PRINT
tokens SYM_EQUALITY SYM_NOTEQ SYM_LT SYM_LEQ SYM_GT SYM_GEQ
non-terminals S INSTR INSTRS LINSTRS ELSE EXPR FACTOR BLOC
non-terminals LPARAMS REST_PARAMS
non-terminals IDENTIFIER INTEGER
non-terminals FUNDEF FUNDEFS
non-terminals ADD_EXPRS ADD_EXPR
non-terminals MUL_EXPRS MUL_EXPR
non-terminals CMP_EXPRS CMP_EXPR
axiom S
{

  open Symbols
  open Ast
  open BatPrintf
  open BatBuffer
  open Batteries
  open Utils


  let resolve_associativity term other =
	match other with
	|[] -> term
	|_ -> List.fold_left (fun elt acc -> Node(elt[0] [acc, elt[1]]) ) term other


}
rules
S -> FUNDEFS SYM_EOF {  Node (Tlistglobdef, []) }
FUNDEFS -> FUNDEF FUNDEFS {Node (Tfundef, $1)::}
FUNEDFS -> {[]}
FUNDEF -> SYM_IDENTIFIER SYM_LPARENTHESIS LPARAMS SYM_RPARENTHESIS INSTR
LPARAMS -> SYM_IDENTIFIER REST_PARAMS
REST_PARAMS -> SYM_COMMA SYM_IDENTIFIER REST_PARAMS
REST_PARAMS ->
INSTR -> SYM_IDENTIFIER SYM_ASSIGN EXPR SYM_SEMICOLON {resolve_associativity (Tassign, StringLeaf($1)}
INSTR -> SYM_IF SYM_LPARENTHESIS EXPR SYM_RPARENTHESIS BLOC ELSE {(Tif, $2)}
INSTR -> SYM_WHILE SYM_LPARENTHESIS EXPR SYM_RPARENTHESIS INSTR {($1 $2)}
INSTR -> SYM_RETURN EXPR SYM_SEMICOLON
INSTR -> SYM_PRINT EXPR SYM_SEMICOLON
INSTR -> BLOC 

EXPR -> CMP_EXPR CMP_EXPRS {resolve_associativity $1 $2}
CMP_EXPR -> ADD_EXPR ADD_EXPRS {resolve_associativity $1 $2} 
ADD_EXPR -> MUL_EXPR MUL_EXPRS {resolve_associativity $1 $2}
MUL_EXPR -> FACTOR 
FACTOR -> SYM_INTEGER {IntLeaf($1)}
FACTOR -> SYM_IDENTIFIER {StringLeaf($1)}
FACTOR -> SYM_LPARENTHESIS EXPR SYM_RPARENTHESIS 

MUL_EXPRS -> SYM_ASTERISK MUL_EXPR MUL_EXPRS {(Tmul,$2)::$3}
MUL_EXPRS -> SYM_DIV MUL_EXPR MUL_EXPRS {(Tdiv, $2)::$3}
MUL_EXPRS -> SYM_MOD MUL_EXPR MUL_EXPRS {(Tmod, $2)::$3}
MUL_EXPRS -> {[]}
ADD_EXPRS -> SYM_PLUS ADD_EXPR ADD_EXPRS {(Tadd, $2)::$3}
ADD_EXPRS -> SYM_MINUS ADD_EXPR ADD_EXPRS {(Tsub, $2)::$3}
ADD_EXPRS -> {[]}

CMP_EXPRS -> SYM_EQUALITY EXPR CMP_EXPRS {(Tceq, $2)::$3}
CMP_EXPRS -> SYM_NOTEQ EXPR CMP_EXPRS {(Tcne, $2)::$3}
CMP_EXPRS -> SYM_LT EXPR CMP_EXPRS {(Tclt, $2)::$3}
CMP_EXPRS -> SYM_LEQ EXPR CMP_EXPRS {(Tcle, $2)::$3}
CMP_EXPRS -> SYM_GT EXPR CMP_EXPRS {(Tcgt, $2)::$3}
CMP_EXPRS -> SYM_GEQ EXPR CMP_EXPRS {(Tcge, $2)::$3}
CMP_EXPRS -> {[]}

ELSE -> SYM_ELSE BLOC {}
ELSE -> {[]}
BLOC -> SYM_LBRACE INSTRS SYM_RBRACE {(Tblock, $2)}
INSTRS -> INSTR INSTRS {resolve_associativity $1 $2}
INSTRS -> {[]}
